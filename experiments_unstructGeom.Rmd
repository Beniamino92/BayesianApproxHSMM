---
title: "HSMM_HMM_GaussianEmission_unstructuredGeometricDwell"
author: "Jack Jewson"
date: "18 March 2020"
output: html_document
---




## Set up

```{r set_up, include=TRUE, echo=FALSE, eval=TRUE, cache=TRUE, results='hide'}
library("miceadds")
library("rstan")
library("bayesplot")
library("bridgesampling")

# setwd("C:/Users/JeJewson/Documents/Barcelona_Yr1/bennisCode")
# setwd("C:/Users/Rachel Wilkerson/Documents/JackFiles")
setwd("/Users/beniamino/Desktop/HSMM_Project/Temp/")
source("include/util_unstructuredGeometric.R")

rstan_options(auto_write = TRUE)
```

## Data Generation 

Firstly we generate data from exactly the model targetted by the HSMM/HMM


```{r data_generation, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# - Parameterization:

#N <- 200  # length time series
N <- 1000
K <- 3 # n. states
gamma <- matrix(c(0, 0.3, 0.7,
                  0.2, 0, 0.8,
                  0.1, 0.9, 0), K, K, byrow = TRUE) #  t.p.m
m <- c(3, 5, 4)
theta_list <- list() ## The unstructured geometric dwell parameters
theta_list[[1]] <- c(0.1, 0.13, 0.16)#, 0.61) ## I should plot these really. 
theta_list[[2]] <- c(0.05, 0.07, 0.09, 0.11, 0.13)#, 0.55)
theta_list[[3]] <- c(0.08, 0.12, 0.16, 0.2)#, 0.44)
mu <- c(5, 14, 30) # emission parameter - mean
sigma <- c(1, 1, 1) # emission parameters - sd

# - Generate data:

set.seed(5)
simul <- HSMM_generate_unstructuredGeometric_approx(N, K ,theta_list, a_mat = gamma, mu_vec = mu, sigma_vec = sigma)
obs <- simul$y
state <- simul$z
plot(obs, col = state, cex = 0.7, pch = 20, type = "o")

```

## Frequentist MLE

```{r Frequentist_MLE, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

parms_init <- list()
parms_init$theta_simplex_vec <- c(rep(1/4, 4), rep(1/6, 6), rep(1/5, 5))
#parms_init$mu <- rep(0, K)
parms_init$mu <- c(5, 15, 30)
parms_init$sigma <- rep(1, K)
parms_init$gamma <- matrix(c(0, 0.5, 0.5, 
                                 0.5, 0, 0.5, 
                                 0.5, 0.5, 0),  K, K, byrow = T)

K <- 3
m.3 <- m
EM.3 <- HSMM.ECM(K, 
                m.3,  
                obs, 
                parms_init,
                niter = 3e2)

```

```{r Frequentist_MLE_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

cat("mllk:", EM.3$mllk, " AIC:", EM.3$AIC, " BIC:", EM.3$BIC, "\n")
EM.3_pseudo_residuals <- HSMM.pseudo_residuals(obs, m.3, EM.3$theta_simplex_vec, 
                      EM.3$mu, EM.3$sigma, EM.3$gamma, plt = TRUE)
EM.3_viterbi <- HSMM.viterbi(obs, m.3, EM.3$theta_simplex_vec, EM.3$mu, EM.3$sigma, EM.3$gamma, plt = TRUE)


EM.3$mu
mu
EM.3$sigma
sigma
EM.3$theta_simplex_vec[1:4]
c(theta_list[[1]], 1-sum(theta_list[[1]]))
EM.3$theta_simplex_vec[5:10]
c(theta_list[[2]], 1-sum(theta_list[[2]]))
EM.3$theta_simplex_vec[11:15]
c(theta_list[[3]], 1-sum(theta_list[[3]]))
EM.3$gamma
gamma


```

## Bayesian 

```{r Bayesian_hsmm_hmm_fit, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
unstructuredGeometric_bayesian_hsmm_hmm_stan <- stan_model(file = "stan/bayesHSMMapprox_GaussEmis_unstrGeomDur.stan") 
  

unstructuredGeometric_bayesian_hsmm_hmm_data <- list(N = length(obs), K = 3, y = obs, m = m.3, mu_0 = c(5, 15, 30), sigma_0 = 1, alpha_0_gamma = 1, alpha_0_theta = 1)

unstructuredGeometric_bayesian_hsmm_hmm <- sampling(object = unstructuredGeometric_bayesian_hsmm_hmm_stan, data = unstructuredGeometric_bayesian_hsmm_hmm_data, warmup = 1000, iter=(1+5)*1000, chains=1, cores=1, control = list(adapt_delta=0.95,stepsize=0.01,max_treedepth = 20))
unstructuredGeometric_bayesian_hsmm_hmm_params <- extract(unstructuredGeometric_bayesian_hsmm_hmm)


```

So big sigma_0 = gets the mus too big, too small gets them too small, and the variance is blown up to allow for this. So does the variance on the prior for sigma2 affect this.  I could just set better prior means!! Maybe standardising this would make everything easier! If I correctly specify the prior means then we are ok! So we have to be a bit careful with the prior specification (could it be to do woth the Cuachy prior!). This seems to be the fault of a Cuachy priro and a gamma priro seems to fix this. 


```{r Bayesian_hsmm_hmm_fit_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

EM.3$mu
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_params$mu)
mu

EM.3$sigma
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_params$sigma)
sigma 

EM.3$theta_simplex_vec[1:4]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_params$theta)[1:3])
c(theta_list[[1]], 1-sum(theta_list[[1]]))

EM.3$theta_simplex_vec[5:10]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_params$theta)[4:8])
c(theta_list[[2]], 1-sum(theta_list[[2]]))

EM.3$theta_simplex_vec[11:15]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_params$theta)[9:12])
c(theta_list[[3]], 1-sum(theta_list[[3]]))


EM.3$gamma
apply(unstructuredGeometric_bayesian_hsmm_hmm_params$gamma, c(2,3), mean)
gamma

EM.3$mllk
mean(unstructuredGeometric_bayesian_hsmm_hmm_params$lp__)


```


## Bayes factors vs AIC/BIC

So we can now consider sampleing from a standard HMM and then selecting the value of $m$ using Bayes=factors and AIC/BIC

Bit this isn't that interesting as the Poisson doesn't add parameters as m increases like th eunstructured geometric does. 


```{r HMM_data_generation, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}


# Generate a realization of a GaussianâHMM (fixed sd)
gauss.HMM.generate_sample <- 
  function(n, m, mu, gamma, sd = 1, delta = NULL){
    if(is.null(delta))  delta <- solve(t(diag(m)-gamma + 1), rep(1,m))
    mvect <- 1:m
    state <- numeric(n)
    state[1] <- sample(mvect, 1, prob = delta)
    for (i in 2:n){
      state[i] <- sample(mvect, 1, prob = gamma[state[i-1], ])
    }
    x <- rnorm(n, mean = mu[state], sd = sd)
    return(list(x = x, state = state))
  }


# - Generate some HMM data

set.seed(1)

# Data generating parameters
K <- 2
#N <- 500 
#N <- 200
N <- 100
gamma <- matrix(c(0.9, 0.1, 0.3, 0.7), K, K, byrow = T) 
mu <- c(1, 6)
sigma <- c(1,1)

# Simulated data and sequence
simul <- gauss.HMM.generate_sample(N, K, mu, gamma, sd = sigma)
data <- simul$x
state <- simul$state

plot(data, col = state, cex = 0.7, pch = 20, type = "o")


```

```{r Frequentist_MLE_m1, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# ----- EM - (K = 2, m = 1) ------ #

## Very sensitive to initalisation. 

K <- 2
m.2m1 <- c(1,1)

parms_init <- list()
parms_init$theta_simplex_vec <- c(c(0.1, 0.9, 0.3, 0.7))
#parms_init$mu <- rep(0, K)
parms_init$mu <- c(1,6)
parms_init$sigma <- rep(1, K)
parms_init$gamma <- matrix(c(0, 1, 
                                 1, 0),  K, K, byrow = T)




EM.2m1 <- HSMM.ECM(K, 
                m = m.2m1, 
                obs = data, 
                parms_init,
                niter = 3e2)

```



```{r Frequentist_MLE_m1_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

cat("mllk:", EM.2m1$mllk, " AIC:", EM.2m1$AIC, " BIC:", EM.2m1$BIC, "\n")
EM.2m1_pseudo_residuals <- HSMM.pseudo_residuals(obs = data, m.2m1, EM.2m1$theta_simplex_vec, 
                      EM.2m1$mu, EM.2m1$sigma, EM.2m1$gamma, plt = TRUE)
EM.2m1_viterbi <- HSMM.viterbi(obs = data, m.2m1, EM.2m1$theta_simplex_vec, EM.2m1$mu, EM.2m1$sigma, EM.2m1$gamma, plt = TRUE)


EM.2m1$mu
mu
EM.2m1$sigma
sigma

EM.2m1$theta_simplex_vec[1:2]
rev(gamma[1,])
EM.2m1$theta_simplex_vec[3:4]
gamma[2,]


EM.2m1$gamma

```

```{r Frequentist_MLE_m2, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# ----- EM - (K = 2, m = 2) ------ #

## Very sensitive to initalisation. 

K <- 2
m.2m2 <- c(2,2)

parms_init <- list()
parms_init$theta_simplex_vec <- c(c(0.1, 0.1*0.9, 0.81, 0.3,0.3*0.7, 0.49))
#parms_init$mu <- rep(0, K)
parms_init$mu <- c(1,6)
parms_init$sigma <- rep(1, K)
parms_init$gamma <- matrix(c(0, 1, 
                                 1, 0),  K, K, byrow = T)


EM.2m2 <- HSMM.ECM(K, 
                m = m.2m2, 
                obs = data, 
                parms_init,
                niter = 3e2)
```



```{r Frequentist_MLE_m2_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

cat("mllk:", EM.2m2$mllk, " AIC:", EM.2m2$AIC, " BIC:", EM.2m2$BIC, "\n")
EM.2m2_pseudo_residuals <- HSMM.pseudo_residuals(obs = data, m.2m2, EM.2m2$theta_simplex_vec, 
                      EM.2m2$mu, EM.2m2$sigma, EM.2m2$gamma, plt = TRUE)
EM.2m2_viterbi <- HSMM.viterbi(obs = data, m.2m2, EM.2m2$theta_simplex_vec, EM.2m2$mu, EM.2m2$sigma, EM.2m2$gamma, plt = TRUE)


EM.2m2$mu
mu
EM.2m2$sigma
sigma

EM.2m2$theta_simplex_vec[1:3]
c(dgeom(c(0,1), p = gamma[1,2]), 1-sum(dgeom(c(0,1), p = gamma[1,2])))
EM.2m2$theta_simplex_vec[4:6]
c(dgeom(c(0,1), p = gamma[2,1]), 1-sum(dgeom(c(0,1), p = gamma[2,1])))


EM.2m2$gamma

```




## Bayesian 

```{r Bayesian_hsmm_hmm_fit_m1, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

unstructuredGeometric_bayesian_hsmm_hmm_stan <- stan_model(file = "stan/bayesHSMMapprox_GaussEmis_unstrGeomDur.stan")


unstructuredGeometric_bayesian_hsmm_hmm_m1_data <- list(N = length(data), K = 2, y = data, m = m.2m1, mu_0 = c(1, 6), sigma_0 = 1, alpha_0_gamma = 1, alpha_0_theta = 1)

unstructuredGeometric_bayesian_hsmm_hmm_m1 <- sampling(object = unstructuredGeometric_bayesian_hsmm_hmm_stan, data = unstructuredGeometric_bayesian_hsmm_hmm_m1_data, warmup = 1000, iter=(1+5)*1000, chains=1, cores=1, control = list(adapt_delta=0.99,stepsize=0.01,max_treedepth = 20))
unstructuredGeometric_bayesian_hsmm_hmm_m1_params <- extract(unstructuredGeometric_bayesian_hsmm_hmm_m1)


```

I think the cauchy prior is a bit of a bad idea. 


```{r Bayesian_hsmm_hmm_fit_m1_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

EM.2m1$mu
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m1_params$mu)
mu

EM.2m1$sigma
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m1_params$sigma)
sigma

EM.2m1$theta_simplex_vec[1:2]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m1_params$theta)[1])
rev(gamma[1,])

EM.2m1$theta_simplex_vec[3:4]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m1_params$theta)[2])
gamma[2,]


library(bridgesampling)

unstructuredGeometric_bayesian_hsmm_hmm_m1_bridge <- bridge_sampler(unstructuredGeometric_bayesian_hsmm_hmm_m1)

unstructuredGeometric_bayesian_hsmm_hmm_m1_bridge$logml


```

```{r Bayesian_hsmm_hmm_fit_m2, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

unstructuredGeometric_bayesian_hsmm_hmm_stan <- stan_model(file = "stan/bayesHSMMapprox_GaussEmis_unstrGeomDur.stan")


unstructuredGeometric_bayesian_hsmm_hmm_m2_data <- list(N = length(data), K = 2, y = data, m = m.2m2, mu_0 = c(1, 6), sigma_0 = 1, alpha_0_gamma = 1, alpha_0_theta = 1)

unstructuredGeometric_bayesian_hsmm_hmm_m2 <- sampling(object = unstructuredGeometric_bayesian_hsmm_hmm_stan, data = unstructuredGeometric_bayesian_hsmm_hmm_m2_data, warmup = 1000, iter=(1+5)*1000, chains=1, cores=1, control = list(adapt_delta=0.95,stepsize=0.01,max_treedepth = 20))
unstructuredGeometric_bayesian_hsmm_hmm_m2_params <- extract(unstructuredGeometric_bayesian_hsmm_hmm_m2)


```



```{r Bayesian_hsmm_hmm_fit_m2_diag, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

EM.2m2$mu
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m2_params$mu)
mu

EM.2m2$sigma
colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m2_params$sigma)
sigma

EM.2m2$theta_simplex_vec[1:3]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m2_params$theta)[1:2])
c(dgeom(c(0,1), p = gamma[1,2]), 1-sum(dgeom(c(0,1), p = gamma[1,2])))
EM.2m2$theta_simplex_vec[4:6]
simplex_create_stickBreaking(colMeans(unstructuredGeometric_bayesian_hsmm_hmm_m2_params$theta)[3:4])
c(dgeom(c(0,1), p = gamma[2,1]), 1-sum(dgeom(c(0,1), p = gamma[2,1])))




library(bridgesampling)

unstructuredGeometric_bayesian_hsmm_hmm_m2_bridge <- bridge_sampler(unstructuredGeometric_bayesian_hsmm_hmm_m2)

unstructuredGeometric_bayesian_hsmm_hmm_m2_bridge$logml


```


```{r Frequentist_MLE_comp, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE}

## The negative log-likelihood. Want to minimise
EM.2m1$mllk
EM.2m2$mllk

EM.2m1$AIC
EM.2m2$AIC

EM.2m1$BIC
EM.2m2$BIC


## Maximise
unstructuredGeometric_bayesian_hsmm_hmm_m1_bridge$logml
unstructuredGeometric_bayesian_hsmm_hmm_m2_bridge$logml

## Posterior probability of the correct smaller model.
exp(unstructuredGeometric_bayesian_hsmm_hmm_m1_bridge$logml - logsumexp(c(unstructuredGeometric_bayesian_hsmm_hmm_m1_bridge$logml,unstructuredGeometric_bayesian_hsmm_hmm_m2_bridge$logml)))

## Posterior pseudo probability using AIC
exp(-EM.2m1$AIC - logsumexp(c(-EM.2m1$AIC,-EM.2m2$AIC)))
```


Can we maybe do selection of the number of hidden states. 