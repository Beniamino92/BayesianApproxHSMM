---
title: "experiments_hybrid"
author: "Beniamino Hadj-Amar"
date: "01/04/2020"
output: html_document
---


## Set up

```{r set_up, include=TRUE, echo=FALSE, eval=TRUE, cache=TRUE, results='hide'}

library("miceadds")
library("rstan")
library("bayesplot")
library("bridgesampling")
library("depmixS4")

setwd("/Users/beniamino/Desktop/HSMM_Project/Temp/")
source.all("include/")

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```




# --------------- Data Generation 

# Here we investigate the performance of our approach when the data
# are generated from a 'hybrid' model, i.e a combination of Markovian 
# transitions (geometric duration) and (semi-Markovian) transitions.  
# Though here, Markovian transition are 'actually'approximated' by Poisson(1) (need to be changed.)

```{r data_generation, include=TRUE,echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# -- Parameterization

N <- 650  # length time series
parms <- list()
parms$K <- 3  # n. states
parms$lambda <- c(100, 1, 1) # poisson duration rate
parms$mu <- c(5, 15, 30)  # emission parameter - mean
parms$sigma <- c(1, 1, 1) # emission parameters - sd
parms$gamma <- matrix(c(0, 0.3, 0.7,
                        0.02, 0, 0.99,
                        0.01, 0.99, 0), parms$K, parms$K, byrow = T) #  t.p.m
parms$delta <- c(1.0, 0.0, 0.0) # initial dstr

# - Simulate data

set.seed(5)
simul <- gauss.HSMM.generate_sample(N, parms)
obs <- simul$obs
state <- simul$state
plot(obs, col = state, cex = 0.7, pch = 20, type = "o")
```



# ------------ HSSM approx - Expectation/Conditional Maximization (ECM)


```{r ECM, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

K <- 3
m <- c(20, 2, 2)
lambda.0 <- c(10, 2, 2)
parms.0 <- HSMM.init(obs, K, lambda.0) # initial values
HSMM.ECM <- HSMM.ECM(K = K, m = m, obs = obs, parms_init = parms.0, niter = 1e2)
cat("mllk:", HSMM.ECM$mllk, " AIC:", HSMM.ECM$AIC, " BIC:", HSMM.ECM$BIC, "\n")
```
```{r ECM_out, include=TRUE, echo=TRUE, eval=TRUE, cache=TRUE, results='hide'}
# psuedo residuals + most likely state sequence (viterbi)
HSMM.pseudo_residuals(obs, m, HSMM.ECM$lambda, 
                      HSMM.ECM$mu, HSMM.ECM$sigma, HSMM.ECM$gamma, plt = TRUE)
HSMM.viterbi(obs, m, HSMM.ECM$lambda, HSMM.ECM$mu, HSMM.ECM$sigma, HSMM.ECM$gamma, plt = TRUE)
```




# --------------- HSMM approx -  Bayesian Model 

```{r bayes, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
K <- 3
m <- c(30, 1, 1)
lambda.0 <- c(20, 1, 1)
data.stan <- list(N = length(obs), K = K, y = obs,
                  m = m,  mu_0 = rep(5, K), sigma_0 = 10, 
                  a_0 = c(20, 1, 1), b_0 = rep(1, K), alpha_0 = 1,
                  seed = 1)
HSMM.stan <- stan(file = "stan/bayesHSMMapprox.stan", data = data.stan, iter = 3e3, 
                  chains = 2, init = function(){HSMM.init.stan(K, obs, lambda.0)})
print(HSMM.stan, probs = c(0.05, 0.95))$summary
```
```{r bayes_out, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# --- extracting samples 
sims <- extract(HSMM.stan)
lambda_sims <- sims$lambda
mu_sims <- sims$mu
sigma_sims <- sims$sigma
gamma_sims <- get.gamma_sims(sims$gamma)

# --- bayes estimates
lambda.hat <- colMeans(lambda_sims)
mu.hat <- colMeans(mu_sims)
sigma.hat <- colMeans(sigma_sims)
gamma.hat <- apply(gamma_sims, c(1, 2), mean)

# psuedo residuals + most likely state sequence (viterbi)
HSMM.pseudo_residuals(obs, m, lambda.hat, mu.hat, sigma.hat, gamma.hat, plt = TRUE)
HSMM.viterbi(obs, m, lambda.hat, mu.hat, sigma.hat,gamma.hat, draw = FALSE, plt = TRUE) 
```
```{r bayes_diag, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

# -- posterior predictive plot check
HSMM.predictive.plot(sims, obs, m)
```
```{r bayes_diag, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
# --- predictive performances
HSMM.performance <- HSMM.stan.performance(sims, obs, m)
HSMM.performance
```


# ------------ HMM standard  - Bayes  

```{r bayes_mu, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}

K <- 3
data.stan <- list(N = length(obs), K = K, y = obs,
                  mu_0 = rep(0, K), sigma_0 = 10, alpha_0 = 1)
HMM.stan <- stan(file = "stan/bayesHMM.stan", data = data.stan, iter = 3e3, 
                 chains = 2, init = function(){emis.init(obs, K)}, 
                 seed = 0)
print(HMM.stan, probs = c(0.05, 0.95))
```

```{r bayes_mu, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
# --- extracting samples 
sims <- extract(HMM.stan)
mu_sims <- sims$mu
sigma_sims <- sims$sigma
gamma_sims <- sims$gamma

# --- bayes estimates
mu.hat <- colMeans(mu_sims)
sigma.hat <- colMeans(sigma_sims)
gamma.hat <- apply(gamma_sims, c(2, 3), mean)

# psuedo residuals + most likely state sequence (viterbi)
HSMM.pseudo_residuals(obs, m, lambda.hat, mu.hat, sigma.hat, gamma.hat, plt = TRUE)
HSMM.viterbi(obs, m, lambda.hat, mu.hat, sigma.hat,gamma.hat, draw = FALSE, plt = TRUE) 

```

```{r bayes_mu, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
# performance measures 
HMM.performance <- HMM.stan.performance(sims, obs)
HMM.performance
```



# ------------ Comparing HSMM vs HMM  - Bayes Factor 

```{r bayes_gamma, include=TRUE, echo=TRUE, eval=TRUE,cache=TRUE,results='hide'}
HMM.marg_lik <- bridge_sampler(HMM.stan)
HSMM.marg_lik <- bridge_sampler(HSMM.stan)
exp(HSMM.marg_lik$logml - HMM.marg_lik$logml) # bayes factor 
```




